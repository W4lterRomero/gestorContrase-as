import { FastifyInstance } from 'fastify';
import { z } from 'zod';
import bcrypt from 'bcryptjs';
import { prisma } from '../lib/prisma';

const registerSchema = z.object({
    email: z.string().email(),
    // Client sends us the HASH of the Auth Key, not the password
    authKeyHash: z.string(),
    // Salts generated by client
    saltAuth: z.string(),
    saltEnc: z.string(),
});

const loginSchema = z.object({
    email: z.string().email(),
    authKeyHash: z.string(),
});

export async function authRoutes(fastify: FastifyInstance) {
    // Register
    fastify.post('/register', async (request, reply) => {
        try {
            const body = registerSchema.parse(request.body);

            // Check if user exists
            const exists = await prisma.user.findUnique({
                where: { email: body.email }
            });

            if (exists) {
                return reply.code(409).send({ error: 'User already exists' });
            }

            // Hash the authKeyHash again for storage (double hashing)
            // This ensures even if DB leaks, attackers can't impersonate client easily
            const hashedAuthKey = await bcrypt.hash(body.authKeyHash, 10);

            // Create user
            const user = await prisma.user.create({
                data: {
                    email: body.email,
                    authKeyHash: hashedAuthKey,
                    saltAuth: body.saltAuth,
                    saltEnc: body.saltEnc,
                    vault: {
                        create: {
                            encryptedData: '{}',
                            iv: '',
                            version: 1
                        }
                    }
                }
            });

            // Generate JWT
            const token = fastify.jwt.sign({
                userId: user.id,
                email: user.email
            });

            return {
                token,
                userId: user.id,
                message: 'Account created successfully'
            };
        } catch (error) {
            request.log.error(error);
            return reply.code(400).send({ error: 'Invalid request' });
        }
    });

    // Get Salt (Pre-login step)
    fastify.post('/get-salt', async (request, reply) => {
        const { email } = request.body as { email: string };

        const user = await prisma.user.findUnique({
            where: { email }
        });

        if (!user) {
            // Return fake salt to prevent enumeration?
            // For now, simpler error
            return reply.code(404).send({ error: 'User not found' });
        }

        return { saltAuth: user.saltAuth };
    });

    // Login
    fastify.post('/login', async (request, reply) => {
        try {
            const { email, authKeyHash } = loginSchema.parse(request.body);

            const user = await prisma.user.findUnique({
                where: { email }
            });

            if (!user) {
                return reply.code(401).send({ error: 'Invalid credentials' });
            }

            // Verify the Auth Key Hash
            const valid = await bcrypt.compare(authKeyHash, user.authKeyHash);

            if (!valid) {
                return reply.code(401).send({ error: 'Invalid credentials' });
            }

            const token = fastify.jwt.sign({
                userId: user.id,
                email: user.email
            });

            return {
                token,
                userId: user.id,
                saltEnc: user.saltEnc // Client needs this to derive MasterEncryptionKey
            };
        } catch (error) {
            request.log.error(error);
            return reply.code(400).send({ error: 'Invalid request' });
        }
    });
}
